#!/usr/bin/env python
import subprocess, os, getpass, time

if __name__ == '__main__':

  # define the status codes
  STATUS_NOT_SUBMITTED = 0
  STATUS_RUNNING       = 1
  STATUS_FINISHED      = 2
  STATUS_FAILED        = 3

  # create a list of targets and necessary meta-information associated w/ each job
  jobs = { {% for targetFile, logFile, bashScript in zippedInfo %}
    '{{ targetFile }}' : {
      'logFile'    : '{{ logFile }}',
      'bashScript' : '{{ bashScript }}',
      'ID'         : -1,
      'status'     : STATUS_NOT_SUBMITTED,
      'retries'    : 0,
    },{% endfor %}
  }

  # update the queue priority if needed
  priority = '{{ priority }}'
  priority_env = os.environ.get('SBATCH_PRIORITY')
  if priority_env:
    priority = priority_env
  if not priority:
    priority = "main"

  squeueCommand = "squeue -u %s | tail -n+2 | awk '{print $1}'" % getpass.getuser()
  while True:
    # fetch the IDs of running jobs
    squeueProcess = subprocess.Popen(
      squeueCommand,
      stdout = subprocess.PIPE,
      stderr = subprocess.PIPE,
      shell  = True)
    runningIDs = squeueStdout.rstrip('\n').split('\n')

    #update status here
    for target, entry in jobs.iteritems():
      if entry['status'] == STATUS_RUNNING and entry['ID'] not in runningIDs:
        if os.path.exists(target):
          entry['status'] = STATUS_FINISHED
        else:
          if entry['retries'] > {{ maxRetries }}:
            # if the number of resubmission exceeds certain threshold, mark it as failed
            entry['status'] = STATUS_FAILED
          else:
            # otherwise resubmit the job
            entry['status'] = STATUS_NOT_SUBMITTED

    # check if all jobs have been finished
    if all([jobs[t]['status'] in (STATUS_FINISHED, STATUS_FAILED) for t in jobs]):
      break

    # submit new jobs if needed
    nof_running = len([jobst[t]['status'] == STATUS_RUNNING])
    for target, entry in jobs.iteritems():

      # check if the number of running jobs exceeds the limit
      if nof_running >= {{ limit }}:
        break

      if entry['status'] == STATUS_NOT_SUBMITTED:
        # submit the job
        submitJobProcess = subprocess.Popen(
          'sbatch --partition={priority} --output={logFile} {bashScript}'.format(
            priority   = priority,
            logFile    = entry['logFile'],
            bashScript = entry['bashScript'],
          ),
          stdout = subprocess.PIPE,
          stderr = subprocess.PIPE,
          shell  = True
        )
        submitStdout, submitStderr = submitJobProcess.communicate()
        entry['ID']       = submitStdout.rstrip('\n').split()[-1]
        entry['status']   = STATUS_RUNNING
        entry['retries'] += 1
        nof_running += 1

      else:
        raise ValueError("Internal error")

    # wait a little
    time.sleep(30)
